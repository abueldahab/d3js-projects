// Generated by CoffeeScript 1.6.3
(function() {
  stoicReady(1, function() {
    "use strict";
    return define("stc_dendrogram", ["d3", "utils"], function(d3, utils) {
      var perspective;
      perspective = {
        identifier: "stc_dendrogram"
      };
      perspective.bind = function($scope, $container, demoData) {
        var $content, addNode, blankNode, canClick, centerNode, centerNodeName, circleCentral, clean, colorField, compact, computeChildren, computeHasChildren, computeRoot, createIcon, currentRow, d3content, data, diagonal, dragAndDrop, dragging, duration, dx, dy, elementDragged, elementSelected, emptyColor, err, fullColor, g, getColor, getIcon, getId, getMidPosition, getName, getParentId, getPosition, getTranslationXY, iconField, initPos, isNodeCentralClicked, maxY, minY, moveSvg, newH, nextDown, nextPlace, nextUp, nodeCentral, nodeSelected, nodes, nodesComputed, okToDrag, oldH, onCircleClick, onNodeCentralClicked, onRootsComputed, parentField, positionField, ratio, removeNode, root, rootId, rootName, self, setColor, setIcon, setName, setPosition, space, timerDrag, toggle, toggleAll, top, tree, update, vis, yTranslation, _h, _w;
        self = this;
        try {
          clean = function(node) {
            node = _(node).cloneDeep();
            delete node.x0;
            delete node.x;
            delete node.y0;
            delete node.y;
            delete node.hasChildren;
            delete node.children;
            delete node._children;
            delete node.parent;
            delete node.parentLink;
            delete node.depth;
            delete node.color;
            return node;
          };
          $content = $("<div>").addClass("stc-dendrogram-perspective").addClass("dendrogram").appendTo($container);
          $content.height($container.outerHeight());
          $content.width($container.outerWidth());
          $container.css({
            "overflow-x": "auto",
            "overflow-y": "auto"
          });
          parentField = "parentId";
          iconField = "icon";
          positionField = "position";
          colorField = "color";
          data = void 0;
          d3content = d3.select($content.get(0));
          space = 160;
          canClick = true;
          centerNode = void 0;
          centerNodeName = void 0;
          top = 100;
          ratio = 1;
          duration = 500;
          okToDrag = false;
          nodes = void 0;
          _w = $content.outerWidth();
          _h = $content.outerHeight() - 20;
          dragging = null;
          elementSelected = void 0;
          nodeSelected = void 0;
          oldH = _h;
          newH = void 0;
          blankNode = {};
          nodeCentral = void 0;
          self.onRecordUpdate = function(record) {};
          self.onRecordCreate = function(record) {};
          self.onRecordRemove = function(id) {};
          tree = d3.layout.tree().size([_h, _w]).sort(function(a, b) {
            return d3.ascending(getPosition(a), getPosition(b));
          });
          diagonal = d3.svg.diagonal().projection(function(d) {
            return [d.x, d.y];
          });
          vis = d3content.append("svg:svg").attr("width", "100%").attr("height", "100%").append("svg:g").attr("transform", "translate(" + 10 + "," + top + ")");
          g = $content.children("svg").children("g:first-child");
          fullColor = utils.getColor(".COLORS.blue");
          emptyColor = utils.getColor(".COLORS.white");
          getName = function(d) {
            var name;
            name = d.name;
            if (name) {
              return name;
            } else {
              return "";
            }
          };
          compact = function(name) {
            var size;
            size = 16;
            if (name.length <= size) {
              return name;
            } else {
              return name.substring(0, size) + "â€¦";
            }
          };
          setName = function(d, name) {
            d.name = name;
            return update(d);
          };
          getColor = function(d) {
            if (colorField) {
              if (!d[colorField]) {
                setColor(d, fullColor);
              }
              return utils.getColor(d[colorField]);
            } else {
              return fullColor;
            }
          };
          setColor = function(d, color) {
            return d[colorField] = color;
          };
          getPosition = function(d) {
            if (!d[positionField]) {
              d[positionField] = utils.hash(getName(d));
            }
            return d[positionField];
          };
          setPosition = function(d, pos, persist) {
            if (pos !== getPosition(d)) {
              return d[positionField] = pos;
            }
          };
          getMidPosition = function(up, down) {
            if (!up) {
              return getPosition(down) / 2;
            } else if (!down) {
              return getPosition(up) * 2;
            } else {
              return (getPosition(up) + getPosition(down)) / 2;
            }
          };
          getParentId = function(d) {
            if (d.parent) {
              return getId(d.parent);
            } else {
              if (d[parentField]) {
                return d[parentField];
              } else {
                return "";
              }
            }
          };
          getId = function(d) {
            if (d && d.id) {
              return d.id;
            } else {
              return null;
            }
          };
          moveSvg = function(callback) {
            var d3g, newHeight, newPos, oldHeight, trans;
            oldHeight = $content.height();
            newHeight = top + (maxY + 1) * space;
            if (newHeight >= _h) {
              $content.stop();
              $content.animate({
                height: newHeight
              }, duration);
              if (newHeight > oldHeight) {
                $container.animate({
                  scrollDown: newHeight
                }, duration);
              }
            } else if (newHeight < _h) {
              $content.animate({
                height: _h
              }, duration);
            }
            newPos = (newHeight > _h / 2 && maxY > 1 ? minY * space + top : top);
            d3g = d3.select(g[0]);
            trans = getTranslationXY(d3g);
            if (newPos !== trans.y) {
              return d3g.transition().duration(duration).attr("transform", "translate(" + trans.x + "," + newPos + ")").each("end", callback);
            } else {
              if (callback) {
                return callback();
              }
            }
          };
          yTranslation = /translate\(\s*([^\s,)]+)[ ,]([^\s,)]+)/;
          getTranslationXY = function(d) {
            var parts;
            parts = yTranslation.exec(d.attr("transform"));
            return {
              x: parseInt(parts[1], 10),
              y: parseInt(parts[2], 10)
            };
          };
          removeNode = function(d, callback) {
            var c, i, l, p;
            if (d.parent && d.parent.children) {
              p = d.parent;
              c = p.children;
              l = p.children.length;
              i = 0;
              while (i < l) {
                if (getId(c[i]) === getId(d)) {
                  c.splice(i, 1);
                  break;
                }
                i++;
              }
              return update(d, callback);
            }
          };
          addNode = function(d, newParent) {
            d.parent = newParent;
            d[parentField] = clean(newParent).id || null;
            d.depth = newParent.depth + 1;
            if (!newParent.hasChildren) {
              newParent.hasChildren = true;
              newParent.children = [d];
              return update(newParent);
            } else if (!newParent.children && !newParent._children) {
              return computeChildren(newParent, function() {
                return onCircleClick(newParent);
              });
            } else if (!newParent.children && newParent._children) {
              newParent._children.push(d);
              onCircleClick(newParent);
              return canClick = true;
            } else if (newParent.children) {
              newParent.children.push(d);
              return update(newParent);
            }
          };
          computeRoot = function(d, callback) {
            var child, children, id, k, l, nb, temp;
            k = 0;
            nb = 0;
            id = (d ? getId(d) : null);
            children = _(demoData).filter(function(node) {
              return node[parentField] === id;
            }).value();
            l = children.length;
            centerNodeName = root.name;
            if (d) {
              centerNodeName = getName(d);
              centerNode = d;
            }
            temp = $("<span>").text(compact(centerNodeName)).appendTo($content);
            top = 25 + temp.height();
            temp.remove();
            if (id === null && l === 1) {
              child = children[0];
              root.id = child.id;
              return computeRoot(child, callback);
            } else if (l > 0) {
              return children.forEach(function(child) {
                return computeHasChildren(child, function() {
                  child.parent = root;
                  root.children.push(child);
                  if (++nb === l) {
                    return callback();
                  }
                });
              });
            } else {
              return callback();
            }
          };
          computeChildren = function(d, callback) {
            var children, err, id, l, nb;
            try {
              if (d.hasChildren && !d.children && !d._children) {
                id = getId(d) || null;
                nb = 0;
                children = _(demoData).filter(function(node) {
                  return node[parentField] === id;
                }).value();
                l = children.length;
                return children.forEach(function(child) {
                  return computeHasChildren(child, function() {
                    if (++nb === l) {
                      d._children = children;
                      return callback();
                    }
                  });
                });
              } else {
                return callback();
              }
            } catch (_error) {
              err = _error;
              return self.error(err);
            }
          };
          computeHasChildren = function(d, callback) {
            var hasChildren;
            hasChildren = _(demoData).filter(function(node) {
              return node[parentField] === d.id;
            }).value().length > 0;
            d.hasChildren = hasChildren;
            return callback(hasChildren);
          };
          toggleAll = function(d) {
            if (d.children || d.children) {
              d.children.forEach(toggleAll);
              return toggle(d);
            }
          };
          toggle = function(d) {
            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
            return console.log(d);
          };
          getIcon = function(d) {
            if (iconField && d[iconField]) {
              return d[iconField];
            }
          };
          setIcon = function(d, icon) {
            return d[iconField] = icon;
          };
          createIcon = function(d, element) {
            var $body, $fo, foreignObject, toLeft;
            toLeft = !d.toLeft ^ d.hasChildren;
            foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
            $(element).children("foreignObject").remove();
            $fo = $(foreignObject);
            $body = $(document.createElement("body"));
            $fo.attr("x", (toLeft ? "0.5em" : "-1.7em")).attr("y", "-0.85em").attr("width", "2em").attr("height", "2em").append($body);
            $body.css({
              "background-color": "transparent",
              color: getColor(d),
              overflow: "hidden",
              padding: 0
            });
            $body.append("<i class=\"" + getIcon(d) + "\"></i>");
            $fo.appendTo(element);
            return $fo;
          };
          onCircleClick = function(d, callback) {
            var e;
            try {
              if (canClick) {
                canClick = false;
                toggle(d);
                return update(d, function() {
                  canClick = true;
                  if (callback) {
                    return callback();
                  }
                });
              }
            } catch (_error) {
              e = _error;
              return self.error(e);
            }
          };
          maxY = 0;
          minY = 0;
          update = function(source, callback) {
            var d, e, hasChildren, i, len, nb, _results;
            try {
              nodes = tree.nodes(root);
              console.log("New nodes:", nodes);
              root.x = _w / 2 - space;
              nb = 0;
              d = void 0;
              len = nodes.length;
              maxY = 0;
              hasChildren = function() {
                d.y = d.depth * space;
                d.x = d.x * ratio + space;
                if (d.depth > maxY) {
                  maxY = d.depth;
                }
                if (++nb === len) {
                  moveSvg();
                  return nodesComputed(root, source, nodes, callback);
                }
              };
              i = 0;
              _results = [];
              while (i < len) {
                d = nodes[i];
                computeHasChildren(d, hasChildren);
                _results.push(i++);
              }
              return _results;
            } catch (_error) {
              e = _error;
              return self.error(e);
            }
          };
          nextUp = void 0;
          nextDown = void 0;
          nextPlace = void 0;
          currentRow = 0;
          dragAndDrop = function(d, x, y) {
            var diff, newNextDown, newNextUp, oldDiffD, oldDiffU, row;
            newNextUp = void 0;
            newNextDown = void 0;
            row = void 0;
            diff = void 0;
            oldDiffD = void 0;
            oldDiffU = void 0;
            row = Math.ceil((y - space / 2) / space);
            if (row !== 0) {
              if (currentRow !== row) {
                currentRow = row;
                newNextUp = null;
                newNextDown = null;
              }
              oldDiffD = 10000;
              oldDiffU = -10000;
              nodes.forEach(function(node) {
                if (Math.abs(currentRow) === node.depth && !node.isBlank) {
                  diff = node.x - y;
                  if (diff > 0 && diff < oldDiffD) {
                    newNextDown = node;
                    return oldDiffD = diff;
                  } else if (diff < 0 && diff > oldDiffU) {
                    newNextUp = node;
                    return oldDiffU = diff;
                  }
                }
              });
              if ((getId(newNextUp) !== getId(nextUp) || getId(newNextDown) !== getId(nextDown)) && (newNextUp || newNextDown)) {
                nextUp = newNextUp;
                nextDown = newNextDown;
                nextPlace = nextUp || nextDown;
                removeNode(blankNode);
                blankNode = {
                  isBlank: true,
                  parent: nextPlace.parent,
                  depth: nextPlace.depth,
                  id: "___blank",
                  x: 0,
                  y: 0,
                  x0: 0,
                  y0: 0
                };
                setPosition(blankNode, getMidPosition(nextUp, nextDown));
                return addNode(blankNode, nextPlace.parent);
              }
            }
          };
          dx = 0;
          dy = 0;
          initPos = void 0;
          timerDrag = void 0;
          elementDragged = void 0;
          nodesComputed = function(root, source, nodes, onEndCallback, onClickCallback) {
            var e, end, link, node, nodeEnter, nodeExit, nodeUpdate;
            try {
              end = false;
              node = vis.selectAll("g.node.right").data(nodes.slice(1), function(d) {
                return getId(d);
              });
              nodeEnter = node.enter().append("svg:g").attr("class", "node right").attr("transform", function(d) {
                return "translate(" + source.x0 + "," + source.y0 + ")";
              }).attr("opacity", function(d) {
                if (d.isBlank) {
                  return 0;
                } else {
                  return 1;
                }
              }).on("click", function(d, i, onClickCallback) {
                var id;
                if (canClick) {
                  if (elementSelected) {
                    elementSelected.classed("highlighted", false);
                  }
                  elementSelected = d3.select(this);
                  elementSelected.classed("highlighted", true);
                  nodeSelected = d;
                  id = getId(d);
                  if (d.hasChildren) {
                    if (!d.children) {
                      return computeChildren(d, function() {
                        return onCircleClick(d, onClickCallback);
                      });
                    } else {
                      return onCircleClick(d, onClickCallback);
                    }
                  }
                }
              }).call(d3.behavior.drag().on("drag", function(d) {
                if (!elementDragged) {
                  elementDragged = d3.select(this);
                }
                if (!dragging) {
                  dx = 0;
                  dy = 0;
                  dragging = d;
                  initPos = getTranslationXY(elementDragged);
                  elementDragged.attr("class", "node");
                  $(this).css("pointer-events", "none");
                  d3.select(d.parentLink).attr("opacity", 0);
                  removeNode(d);
                }
                dx += d3.event.dx;
                dy += d3.event.dy;
                if (dragging) {
                  dragAndDrop(d, initPos.x + dx, initPos.y + dy);
                  return elementDragged.attr("transform", "translate(" + (initPos.x + dx) + "," + (initPos.y + dy) + ")");
                }
              }).on("dragend", function(d) {
                if (dragging) {
                  $(this).css("pointer-events", "auto");
                  elementDragged.attr("class", "node right");
                  d3.select(this).attr("opacity", 1).transition().duration(duration / 2).attr("opacity", 0);
                  dragging = null;
                  elementDragged = null;
                  if (nextPlace) {
                    setPosition(d, getMidPosition(nextUp, nextDown), true);
                    addNode(d, nextPlace.parent);
                  } else {
                    addNode(d, d.parent);
                  }
                  return removeNode(blankNode);
                }
              })).each(function(d) {
                if (getIcon(d)) {
                  return createIcon(d, this);
                }
              });
              nodeEnter.append("svg:circle").attr("r", 1e-6).style("stroke", function(d) {
                return getColor(d);
              }).style("fill", function(d) {
                if (!d.children && d.hasChildren) {
                  return getColor(d);
                } else {
                  return emptyColor;
                }
              });
              nodeEnter.append("svg:title").text(getName);
              nodeEnter.append("svg:text").attr("x", function(d) {
                var s;
                s = (getIcon(d) ? 25 : 10);
                if (d.hasChildren) {
                  return -s;
                } else {
                  return s;
                }
              }).attr("dy", ".35em").attr("text-anchor", function(d) {
                if (d.hasChildren) {
                  return "end";
                } else {
                  return "start";
                }
              }).attr("transform", function(d) {
                if (d.hasChildren) {
                  return "rotate(0)";
                } else {
                  return "rotate(30)";
                }
              }).text(function(d) {
                return compact(getName(d));
              }).style("fill-opacity", 1e-6);
              nodeUpdate = node.transition().duration(duration).attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
              }).each(function(d) {
                if (getIcon(d)) {
                  return createIcon(d, this);
                }
              }).each("end", function() {
                if (!end) {
                  end = true;
                  if (typeof onEndCallback === "function") {
                    return onEndCallback(source);
                  }
                }
              });
              nodeUpdate.select("circle").attr("r", 4.5).style("stroke", function(d) {
                return getColor(d);
              }).style("fill", function(d) {
                if (!d.children && d.hasChildren) {
                  return getColor(d);
                } else {
                  return emptyColor;
                }
              });
              nodeUpdate.select("text").text(function(d) {
                return compact(getName(d));
              }).style("fill-opacity", 1);
              nodeExit = node.exit().transition().duration(duration).attr("transform", function(d) {
                return "translate(" + source.x + "," + source.y + ")";
              }).each("end", function() {
                if (!end) {
                  end = true;
                  if (typeof onEndCallback === "function") {
                    return onEndCallback(source);
                  }
                }
              }).remove();
              nodeExit.select("circle").attr("r", 1e-6);
              nodeExit.select("text").style("fill-opacity", 1e-6);
              link = vis.selectAll("path.link.right").data(tree.links(nodes), function(d) {
                return getId(d.target);
              });
              link.enter().insert("svg:path", "g").attr("class", "link right").attr("d", function(d) {
                var o;
                o = {
                  x: source.x0,
                  y: source.y0
                };
                return diagonal({
                  source: o,
                  target: o
                });
              }).attr("opacity", function(d) {
                if (d.target.isBlank) {
                  return 0;
                } else {
                  return 1;
                }
              }).each(function(d) {
                return d.target.parentLink = this;
              }).transition().duration(duration).attr("d", diagonal);
              link.transition().duration(duration).attr("d", diagonal).attr("opacity", function(d) {
                if (d.target.isBlank) {
                  return 0;
                } else {
                  return 1;
                }
              });
              link.exit().transition().duration(duration).attr("d", function(d) {
                var o;
                o = {
                  x: source.x,
                  y: source.y
                };
                return diagonal({
                  source: o,
                  target: o
                });
              }).remove();
              return nodes.forEach(function(d) {
                d.x0 = d.x;
                return d.y0 = d.y;
              });
            } catch (_error) {
              e = _error;
              return self.error(e);
            }
          };
          onNodeCentralClicked = function() {
            var isNodeCentralClicked;
            canClick = true;
            if (!isNodeCentralClicked) {
              minY = 0;
              maxY = 0;
            }
            return isNodeCentralClicked = !isNodeCentralClicked;
          };
          isNodeCentralClicked = false;
          nodeCentral = vis.append("svg:g").attr("id", "nodeCentral").attr("class", "node root").attr("transform", function() {
            return "translate(" + (_w / 2) + "," + 0 + ")";
          }).on("click", function(d) {
            if (canClick) {
              if (elementSelected) {
                elementSelected.classed("highlighted", false);
              }
              elementSelected = d3.select(this);
              elementSelected.classed("highlighted", true);
              nodeSelected = null;
              canClick = false;
              circleCentral.transition().duration(500).style("fill", function(d) {
                if (!isNodeCentralClicked) {
                  return fullColor;
                } else {
                  return emptyColor;
                }
              });
              toggle(root);
              return update(root, function() {
                return onNodeCentralClicked();
              });
            }
          });
          $content.find("#nodeCentral").hide();
          circleCentral = nodeCentral.append("svg:circle").attr("r", 4.5).style("stroke", fullColor).style("fill", emptyColor);
          onRootsComputed = function() {
            nodeCentral.append("svg:title").text(centerNodeName);
            return nodeCentral.append("svg:text").attr("x", function() {
              if (getIcon(root)) {
                return -25;
              } else {
                return -10;
              }
            }).attr("dy", ".35em").attr("text-anchor", "end").text(compact(centerNodeName)).attr("opacity", 1e-6).transition().duration(duration / 2).attr("opacity", 1);
          };
          rootId = _(demoData).find({
            parentId: null
          }).id;
          rootName = _(demoData).find({
            parentId: null
          }).name;
          root = {
            id: rootId,
            name: rootName,
            children: [],
            hasChildren: true,
            x0: _w / 2,
            y0: 0
          };
          return computeRoot(root, function() {
            console.log(root);
            $content.find("#nodeCentral").show();
            return update(root, onRootsComputed);
          });
        } catch (_error) {
          err = _error;
          return perspective.error(err);
        }
      };
      perspective.unbind = function(callback) {
        return callback();
      };
      return perspective;
    });
  });

}).call(this);

/*
//@ sourceMappingURL=stc_dendrogram.map
*/
